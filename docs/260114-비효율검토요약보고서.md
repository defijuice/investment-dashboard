# KVIC 출자사업 자동화 워크플로우 비효율 검토 보고서

**작성일:** 2026-01-14
**검토 대상:** docs/260114-구현흐름.md 및 실제 구현 코드
**검토 범위:** 불필요한 단계, 중복, 일관성 문제, 성능 비효율

---

## 목차

1. [검토 요약](#1-검토-요약)
2. [문서와 구현의 불일치](#2-문서와-구현의-불일치)
3. [근본적인 설계 문제](#3-근본적인-설계-문제)
4. [API 호출 비효율 분석](#4-api-호출-비효율-분석)
5. [코드 중복 및 일관성 문제](#5-코드-중복-및-일관성-문제)
6. [에러 처리 및 복구 문제](#6-에러-처리-및-복구-문제)
7. [개선 우선순위](#7-개선-우선순위)
8. [상세 개선 방안](#8-상세-개선-방안)

---

## 1. 검토 요약

### 1.1 전체 평가

| 영역 | 상태 | 심각도 |
|------|------|--------|
| 문서-구현 일치 | 3가지 주요 불일치 | HIGH |
| API 효율성 | 50배 이상 낭비 | CRITICAL |
| 데이터 일관성 | 트랜잭션 부재 | CRITICAL |
| 코드 품질 | 중복 함수 3개 | MEDIUM |
| 에러 복구 | 불가능 | HIGH |

### 1.2 핵심 발견사항

1. **트랜잭션 부재**: 검토 전에 DB에 데이터 생성 → 취소해도 고아 레코드 남음
2. **배치 메서드 미사용**: 이미 구현된 배치 메서드를 사용하지 않아 API 50배 낭비
3. **정규화 함수 불일치**: 3곳에서 다른 정규화 → 운용사 매칭 오류
4. **파일-출자사업 연결 누락**: `/verify` 명령이 제대로 동작하지 않음
5. **탈락 상태 업데이트 없음**: 분리 처리 시 "접수" 상태가 "탈락"으로 변경 안 됨

---

## 2. 문서와 구현의 불일치

### 2.1 불일치 항목 상세

| 항목 | 문서 설명 | 실제 구현 | 영향 |
|------|----------|----------|------|
| PDF 이중 파싱 | Claude + pdfplumber 비교 후 병합 | Claude만 사용 | AI 할루시네이션 검증 불가 |
| 파일-출자사업 연결 | `updateProjectFileId()` 호출 | 함수 존재하나 **미호출** | `/verify` 실패 |
| 탈락 상태 업데이트 | 선정에 없으면 "탈락" | 검토 단계에서만 결정 | 데이터 불일치 |

### 2.2 PDF 이중 파싱 미작동

**문서 (260114-구현흐름.md line 171-186):**
```
방법 1: Claude AI 직접 분석
방법 2: pdfplumber Python 파서
비교 & 병합:
├─ 일치 → 자동 진행
├─ Claude만 발견 → 포함
├─ pdfplumber만 발견 → 스킵
└─ 충돌 → Claude 우선
```

**실제 코드 (process-pair-sheets.js:484-490):**
```javascript
// 접수현황 파싱 (AI 사용)
const { applicants } = await parseApplicationPdf(applicationText, applicationFile);

// 선정결과 파싱 (AI 사용)
const { selected } = await parseSelectionPdfWithAI(selectionText, selectionFile);

// pdfplumber 호출 없음!
// pdf-compare.js의 compareResults() 호출 없음!
```

**영향:**
- AI 할루시네이션 검증 불가
- 복잡한 표 구조 PDF에서 파싱 오류 가능성

### 2.3 파일-출자사업 연결 누락

**구현된 함수 (googleSheets.js:492-536):**
```javascript
async updateProjectFileId(projectId, fileType, fileId) {
  // 중복 연결 검증
  // DUPLICATE_FILE_LINK 에러 발생
  // 지원파일ID 또는 결과파일ID 업데이트
}
```

**호출 여부 확인:**
```bash
$ grep -r "updateProjectFileId" src/processors/
# 결과 없음 - 호출하지 않음
```

**영향:**
- 출자사업 시트의 지원파일ID, 결과파일ID 컬럼이 비어있음
- `/verify` 실행 시 파일 목록 조회 실패
- 파일-출자사업 관계 추적 불가

### 2.4 탈락 상태 업데이트 미구현

**문서 설명:**
```
접수현황에 있고 + 선정결과에 없음 → 탈락
```

**현재 구현:**
- 접수+선정 동시 처리 시: 검토 단계에서 `selectedNames` 세트로 비교하여 상태 결정 (OK)
- 접수만 먼저 처리 시: 모두 "접수" 상태로 저장
- 나중에 선정 처리 시: 기존 "접수" 상태를 "탈락"으로 업데이트하는 로직 **없음**

---

## 3. 근본적인 설계 문제

### 3.1 핵심 문제 1: 트랜잭션 부재 (가장 심각)

**현재 처리 순서:**
```
[3] 출자사업 생성 ← DB 변경
[4] 파일DB 생성 ← DB 변경
[5.5] 운용사 생성 ← DB 변경
[6] 검토 화면 (사용자 입력 대기)
[사용자 거절] → 이미 생성된 데이터가 고아로 남음
```

**올바른 순서:**
```
[1-5] 모든 데이터 파싱 및 검증 (메모리에서만)
[6] 검토 화면 (사용자 입력 대기)
[사용자 승인 후에만]
[7-10] DB 저장 (한 번에)
```

**문제 코드 (process-pair-sheets.js:570-615):**
```javascript
// [6] 검토 준비 단계에서 이미 운용사 생성
for (const applicant of applicants) {
  operator = await sheets.getOrCreateOperator(applicant.name, ...);
  // ← 여기서 DB에 INSERT됨!
}

// 검토 화면
const approved = await review.start();

if (!approved) {
  console.log('\n처리가 취소되었습니다.');
  process.exit(0);
  // ← 이미 생성된 운용사는 DB에 남음
}
```

**영향:**
- 취소해도 운용사 레코드 남음 (고아 데이터)
- 중간 실패 시 부분 데이터만 저장
- 재실행 시 중복 생성 위험

### 3.2 핵심 문제 2: 배치 메서드 미사용 (50배 성능 저하)

**구현된 배치 메서드 (사용 안 함):**
- `createApplicationsBatch()` - googleSheets.js:568
- `createOperatorsBatch()` - googleSheets.js:613

**실제 호출 (개별 루프):**
```javascript
// process-pair-sheets.js:626-688
for (const applicant of finalApplicants) {
  await createApplicationRecord({...});
  // 내부:
  //   const newId = await sheets.getNextId('신청현황', 'AP');  // API 호출 1
  //   await this.appendRows('신청현황', [newRow]);              // API 호출 2
  // = 170건 × 2 = 340 API 호출
}
```

**배치 사용 시:**
```javascript
const dataList = finalApplicants.map(a => ({...}));
await sheets.createApplicationsBatch(dataList);
// = 2 API 호출 (getAllRows 1회 + appendRows 1회)
```

**성능 비교:**

| 항목 | 현재 | 배치 사용 시 | 차이 |
|------|------|-------------|------|
| 신청현황 생성 (170건) | 340회 | 2회 | **170배** |
| 운용사 생성 (50건) | 100회 | 2회 | **50배** |
| 약어 업데이트 (10건) | 20회 | 1회 | **20배** |

### 3.3 핵심 문제 3: 정규화 함수 불일치

**3곳의 다른 정규화 구현:**

```javascript
// 1. operator-matcher.js:133-140 (가장 엄격)
function normalizeName(name) {
  return name
    .toLowerCase()
    .replace(/[()（）\[\]【】]/g, '')  // 괄호 전체 제거
    .replace(/[,.\-_&]/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();
}

// 2. process-pair-sheets.js:329-336 (영문 접미사 제거 포함)
function normalizeName(name) {
  return name
    .toLowerCase()
    .replace(/[,.\-()]/g, ' ')  // 괄호를 공백으로 (다름!)
    .replace(/\s+/g, ' ')
    .replace(/\b(llc|inc|ltd|pte|limited|management|company|co)\b/gi, '')
    .trim();
}

// 3. review-workflow.js:478-485 (또 다른 구현)
function normalizeName(name) {
  // 다른 로직...
}
```

**결과 예시:**
```
입력: "ABC (Korea) Inc."

operator-matcher:     "abc korea inc"
process-pair-sheets:  "abc  korea"     ← 괄호가 공백, Inc 제거
review-workflow:      ???              ← 또 다른 결과

→ 같은 운용사가 매칭 실패!
```

### 3.4 핵심 문제 4: 데이터 중복 저장 및 비효율적 검색

**selectedNames + selectionMap 4중 정규화:**
```javascript
// process-pair-sheets.js:540-552
const selectedNames = new Set();
for (const s of selected) {
  selectedNames.add(normalizeName(s.name));           // 정규화 1회
  selectedNames.add(normalizeName(expandAlias(s.name))); // 정규화 2회
}

const selectionMap = new Map();
for (const s of selected) {
  selectionMap.set(normalizeName(s.name), s);        // 정규화 3회 (중복)
  selectionMap.set(normalizeName(expandAlias(s.name)), s); // 정규화 4회 (중복)
}
```

**Map을 만들고도 전체 순회:**
```javascript
// process-pair-sheets.js:648-660
let selectionData = selectionMap.get(normalizedName);
if (!selectionData && isSelected) {
  for (const [key, value] of selectionMap) {  // O(n) 전체 순회!
    if (key.includes(normalizedName) || normalizedName.includes(key)) {
      selectionData = value;
      break;
    }
  }
}
```

**문제:**
- Map의 O(1) 조회 장점을 활용하지 못함
- 부분 문자열 매칭으로 전체 순회 → O(n²) 가능
- 170개 × 50개 = 최대 8,500회 비교

### 3.5 핵심 문제 5: 에러 복구 불가능

**부분 실패 시나리오:**
```javascript
// process-pair-sheets.js:731-738
if (newAliases.length > 0) {
  for (const { operatorId, alias, fullName } of newAliases) {
    await sheets.updateOperatorAlias(operatorId, alias);
    // 1, 2번: 성공
    // 3번: API 할당량 초과 → throw
    // 4-10번: 실행 안 됨
  }
}
```

**문제:**
- 1, 2번은 이미 저장됨 (롤백 불가)
- 재실행하면 1, 2번 중복 추가 시도
- 어디서 실패했는지 추적 불가
- 체크포인트/재시도 로직 없음

---

## 4. API 호출 비효율 분석

### 4.1 현재 vs 최적 비교 (170건 처리 기준)

| 단계 | 메서드 | 현재 호출 수 | 최적화 시 | 낭비율 |
|------|--------|------------|----------|--------|
| 운용사 조회 | getAllOperators | 3회 | 1회 | 3x |
| 약어 로드 | loadAliasMap | 1회 | 0회 | - |
| 운용사 생성 | getOrCreateOperator×N | ~170회 | 2회 | **85x** |
| 신청현황 생성 | createApplication×N | ~340회 | 2회 | **170x** |
| 약어 업데이트 | updateOperatorAlias×N | ~20회 | 1회 | **20x** |
| 파일 업데이트 | updateFileHistory | 4회 | 4회 | 1x |
| **합계** | | **~538회** | **~10회** | **54x** |

### 4.2 API 호출 흐름 상세

```
processPair() 시작
│
├─ [5.5] reviewNewOperators()
│   └─ getAllOperators() ───────────────────────── API #1
│
├─ [6] 검토 준비
│   └─ for (applicant of applicants) {
│       └─ getOrCreateOperator() ──────────────── API #2 ~ #171
│           └─ findRow() → getAllRows()
│           └─ appendRows() (신규 시)
│       }
│
├─ [7] 신청현황 생성
│   └─ for (applicant of finalApplicants) {
│       └─ createApplicationRecord()
│           └─ getNextId() → getAllRows() ─────── API #172 ~ #341
│           └─ appendRows() ───────────────────── API #342 ~ #511
│       }
│
├─ [7-2] 누락된 선정 운용사
│   └─ for (s of selected) {
│       └─ resolveOperatorId() ────────────────── API #512 ~ #521
│       └─ createApplicationRecord() ──────────── API #522 ~ #541
│       }
│
├─ [8] 약어 저장
│   └─ for (alias of newAliases) {
│       └─ updateOperatorAlias()
│           └─ findById() ─────────────────────── API #542 ~ #551
│           └─ setValues() ────────────────────── API #552 ~ #561
│       }
│
└─ [9] 파일 업데이트 ──────────────────────────── API #562 ~ #565
```

### 4.3 API 할당량 위험

- **Google Sheets API 제한:** 분당 300~600 요청
- **현재 처리량:** 170건에 ~538회 호출
- **위험:** 대량 데이터 처리 시 할당량 초과 가능
- **증상:** `429 Too Many Requests` 에러, 1분 대기 필요

---

## 5. 코드 중복 및 일관성 문제

### 5.1 중복 정의된 함수들

| 함수명 | 위치 1 | 위치 2 | 위치 3 |
|--------|--------|--------|--------|
| `normalizeName()` | operator-matcher.js:133 | process-pair-sheets.js:329 | review-workflow.js:478 |
| `expandAlias()` | process-pair-sheets.js:339 | - | - |
| `matchesAbbreviation()` | operator-matcher.js:190 | - | - |

### 5.2 전역 변수 의존성

```javascript
// process-pair-sheets.js:34-45
let sheets = null;          // 전역
let aliasCache = null;      // 전역
let stats = null;           // 전역
let createdAppIds = null;   // 전역
let newAliases = null;      // 전역
let existingApplications = null;  // 전역
let project = null;         // 전역
let fileDBIds = null;       // 전역
```

**문제:**
- 헬퍼 함수들이 전역 변수에 의존
- 독립적인 테스트 불가능
- 함수 재사용 불가능
- 상태 추적 어려움

### 5.3 하드코딩된 값들

```javascript
// process-pair-sheets.js:514-516
project = await sheets.getOrCreateProject(projectName, {
  소관: isDomestic ? '중기부' : 'KVIC(해외VC)',  // 하드코딩
  공고유형: '정시',  // 하드코딩 - 수시도 있음
  연도: new Date().getFullYear().toString()  // 항상 현재 연도 - PDF에서 추출해야 함
});

// googleSheets.js:678
await this.setValues(`신청현황!I${row._rowIndex}`, [[status]]);
// I열이 항상 상태 필드라고 가정 - 열 순서 변경 시 오류
```

---

## 6. 에러 처리 및 복구 문제

### 6.1 에러 복구 불가능한 구조

**현재 구조:**
```javascript
// 에러 발생 시
processPair(args[0], args[1]).catch(error => {
  console.error('오류 발생:', error.message);
  process.exit(1);
  // 어느 단계에서 실패?
  // 어떤 데이터가 저장됨?
  // 재실행하면 어떻게 됨?
  // → 모두 불명확
});
```

### 6.2 부분 실패 시나리오

| 실패 지점 | 저장된 데이터 | 재실행 시 문제 |
|----------|-------------|--------------|
| [5.5] 운용사 생성 중 | 일부 운용사 | 중복 생성 |
| [7] 신청현황 생성 중 | 일부 신청현황 | 중복 생성 |
| [8] 약어 저장 중 | 일부 약어 | 중복 추가 |
| [9] 파일 업데이트 | 신청현황 완료, 파일 미완료 | 재실행 불가 (이미 존재) |

### 6.3 필요한 개선

1. **체크포인트 시스템:** 각 단계 완료 시 상태 저장
2. **멱등성 보장:** 재실행해도 같은 결과
3. **롤백 로직:** 실패 시 이전 상태로 복원
4. **재시도 로직:** API 할당량 초과 시 자동 재시도

---

## 7. 개선 우선순위

### 7.1 즉시 수정 필요 (Critical)

| 순위 | 항목 | 영향 | 난이도 | 예상 효과 |
|------|------|------|--------|----------|
| 1 | 검토 후 저장 구조 | 고아 데이터 방지 | 높음 | 데이터 일관성 |
| 2 | 배치 메서드 적용 | API 50배 감소 | 낮음 | 성능 50배 향상 |
| 3 | 파일-출자사업 연결 | /verify 정상화 | 낮음 | 기능 복구 |

### 7.2 높은 우선순위 (High)

| 순위 | 항목 | 영향 | 난이도 | 예상 효과 |
|------|------|------|--------|----------|
| 4 | 정규화 함수 통합 | 매칭 정확도 | 낮음 | 오류 방지 |
| 5 | 탈락 상태 업데이트 | 데이터 일관성 | 중간 | 분리 처리 지원 |
| 6 | 에러 복구 로직 | 안정성 | 중간 | 재시도 가능 |

### 7.3 중간 우선순위 (Medium)

| 순위 | 항목 | 영향 | 난이도 | 예상 효과 |
|------|------|------|--------|----------|
| 7 | 전역 변수 제거 | 유지보수 | 중간 | 테스트 가능 |
| 8 | PDF 이중 파싱 활성화 | 정확도 | 중간 | AI 검증 |
| 9 | 하드코딩 제거 | 유연성 | 낮음 | 확장성 |

---

## 8. 상세 개선 방안

### 8.1 검토 후 저장 구조로 변경

**현재:**
```javascript
// [5.5] 유사도 검토 - 운용사 생성
for (const applicant of applicants) {
  operator = await sheets.getOrCreateOperator(...);  // DB 변경
}
// [6] 검토
const approved = await review.start();
// [거절 시] 고아 데이터 남음
```

**개선:**
```javascript
// [5.5] 유사도 검토 - 메모리에서만
const pendingOperators = [];
for (const applicant of applicants) {
  const existing = operatorMap.get(applicant.name);
  if (existing) {
    applicant.operatorId = existing.ID;
  } else {
    pendingOperators.push(applicant.name);
    applicant.operatorId = `PENDING_${pendingOperators.length}`;
  }
}

// [6] 검토
const approved = await review.start();
if (!approved) {
  process.exit(0);  // 아무것도 저장되지 않음
}

// [7] 승인 후 일괄 저장
const newOperatorIds = await sheets.createOperatorsBatch(pendingOperators);
// pendingOperators → 실제 ID로 매핑
```

### 8.2 배치 메서드 적용

**현재:**
```javascript
for (const applicant of finalApplicants) {
  await createApplicationRecord({...});  // 개별 API
}
```

**개선:**
```javascript
// 데이터 수집
const applicationDataList = finalApplicants.map(a => ({
  출자사업ID: project.id,
  운용사ID: a.operatorId,
  출자분야: a.category,
  상태: a.status,
  // ...
}));

// 일괄 저장
const newIds = await sheets.createApplicationsBatch(applicationDataList);
```

### 8.3 파일-출자사업 연결 추가

**추가할 코드 (process-pair-sheets.js [4] 단계 후):**
```javascript
// [4] 파일DB 생성 후에 추가
await sheets.updateProjectFileId(project.id, '접수현황', appFileHistory.id);
await sheets.updateProjectFileId(project.id, '선정결과', selFileHistory.id);
```

### 8.4 정규화 함수 통합

**새 파일 생성: src/utils/normalize.js**
```javascript
/**
 * 운용사명 정규화 (전체 시스템에서 통일)
 */
export function normalizeName(name) {
  return name
    .toLowerCase()
    .replace(/[()（）\[\]【】]/g, '')  // 괄호 제거
    .replace(/[,.\-_&]/g, ' ')         // 특수문자 → 공백
    .replace(/\s+/g, ' ')              // 연속 공백 제거
    .trim();
}

/**
 * 영문 접미사 제거 (비교 시에만 사용)
 */
export function removeEnglishSuffix(name) {
  return name.replace(/\b(llc|inc|ltd|pte|limited|management|company|co)\b/gi, '').trim();
}
```

**각 파일에서 import:**
```javascript
import { normalizeName, removeEnglishSuffix } from '../utils/normalize.js';
```

### 8.5 탈락 상태 업데이트 로직 추가

**선정결과 단독 처리 시 추가할 로직:**
```javascript
// 선정 처리 완료 후
const allApplications = await sheets.getExistingApplications(project.id);

for (const [key, existing] of allApplications) {
  // "접수" 상태이고 선정 명단에 없으면 → "탈락"
  if (existing.status === '접수' && !processedSelectedNames.has(existing.operatorId)) {
    await sheets.updateApplicationStatus(existing.id, '탈락');
  }
}
```

### 8.6 에러 복구 로직

**체크포인트 시스템:**
```javascript
const checkpoint = {
  stage: null,
  completedOperators: [],
  completedApplications: [],
  timestamp: null
};

async function saveCheckpoint() {
  fs.writeFileSync('checkpoint.json', JSON.stringify(checkpoint));
}

async function loadCheckpoint() {
  if (fs.existsSync('checkpoint.json')) {
    return JSON.parse(fs.readFileSync('checkpoint.json'));
  }
  return null;
}
```

**재시도 로직:**
```javascript
async function withRetry(fn, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      if (error.code === 429) {  // Rate limit
        console.log(`API 할당량 초과, ${60}초 대기 후 재시도...`);
        await sleep(60000);
      } else {
        throw error;
      }
    }
  }
  throw new Error('최대 재시도 횟수 초과');
}
```

---

## 부록: 관련 파일 목록

### 분석 대상 파일

| 파일 | 라인 수 | 역할 |
|------|--------|------|
| src/processors/process-pair-sheets.js | 804 | 메인 처리 로직 |
| src/core/googleSheets.js | 1102 | Google Sheets API |
| src/workflows/review-workflow.js | 486 | 검토 워크플로우 |
| src/matchers/operator-matcher.js | 469 | 운용사 유사도 매칭 |
| src/processors/pdf-compare.js | - | PDF 비교 (미사용) |

### 수정이 필요한 파일

| 파일 | 수정 내용 |
|------|----------|
| process-pair-sheets.js | 배치 적용, 파일 연결, 구조 변경 |
| operator-matcher.js | 정규화 함수 import |
| review-workflow.js | 정규화 함수 import |
| (신규) src/utils/normalize.js | 정규화 함수 통합 |

---

## 결론

현재 워크플로우는 **기능적으로는 동작**하지만, **설계적 결함**으로 인해:

1. **API 호출 50배 낭비** → 대량 데이터 처리 불가
2. **트랜잭션 부재** → 고아 데이터 발생
3. **정규화 불일치** → 운용사 매칭 오류
4. **에러 복구 불가** → 부분 실패 시 수동 복구 필요

**즉시 개선이 필요한 항목:**
- 배치 메서드 적용 (난이도 낮음, 효과 높음)
- 파일-출자사업 연결 추가 (난이도 낮음)
- 정규화 함수 통합 (난이도 낮음)

**구조 변경이 필요한 항목:**
- 검토 후 저장 구조 (난이도 높음, 효과 높음)
- 에러 복구 로직 (난이도 중간)
