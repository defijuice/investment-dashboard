# KVIC 출자사업 자동화 워크플로우 비효율 개선 계획

**작성일:** 2026-01-14
**기반 문서:** [260114-비효율검토요약보고서.md](260114-비효율검토요약보고서.md)
**검증 상태:** 코드베이스 분석 완료, 모든 지적 사항 확인됨

---

## 목차

1. [개선 개요](#1-개선-개요)
2. [Phase 1: 즉시 수정 (Critical)](#2-phase-1-즉시-수정-critical)
3. [Phase 2: 구조 개선 (High)](#3-phase-2-구조-개선-high)
4. [Phase 3: 품질 개선 (Medium)](#4-phase-3-품질-개선-medium)
5. [구현 상세](#5-구현-상세)
6. [테스트 및 검증](#6-테스트-및-검증)
7. [롤백 계획](#7-롤백-계획)

---

## 1. 개선 개요

### 1.1 현황 요약

| 영역 | 현재 상태 | 목표 상태 | 개선 효과 |
|------|----------|----------|----------|
| API 효율성 | ~538회/170건 | ~10회/170건 | **54배 감소** |
| 중복 읽기 | 같은 시트 2-4회 | 1회 읽기 후 캐싱 | **60-70% 감소** |
| 데이터 일관성 | 트랜잭션 부재 | 승인 후 저장 | 고아 데이터 방지 |
| 코드 품질 | 중복 함수 4개 | 단일 모듈 | 매칭 정확도 향상 |
| 에러 복구 | 불가능 | 체크포인트 | 재시도 가능 |

### 1.2 개선 우선순위 매트릭스

```
영향도 (높음)
     │
     │  [Phase 1]           [Phase 2]
     │  ● 배치 메서드        ● 트랜잭션 구조
     │  ● 파일 연결          ● 탈락 업데이트
     │  ● 정규화 통합        ● 에러 복구
     │  ● 중복 읽기 제거
     │
     │  [Phase 3]
     │  ● PDF 이중 파싱
     │  ● 전역 변수 제거
     │  ● 하드코딩 제거
     │
     └────────────────────────────────── 구현 난이도 (높음)
         (낮음)
```

---

## 2. Phase 1: 즉시 수정 (Critical)

### 2.1 배치 메서드 적용

**문제:** 구현된 배치 메서드를 사용하지 않아 API 50배 낭비

**현재 코드:**
```javascript
// process-pair-sheets.js:626-688
for (const applicant of finalApplicants) {
  await createApplicationRecord({...});  // 개별 API 호출
}
```

**개선 코드:**
```javascript
// 데이터 수집 (메모리)
const applicationDataList = finalApplicants.map(applicant => ({
  출자사업ID: project.id,
  운용사ID: applicant.operatorId,
  출자분야: applicant.category,
  상태: applicant.status,
  최소결성규모: applicant.minSize,
  모태출자액: applicant.motaeAmount,
  결성예정액: applicant.plannedAmount,
  출자요청액: applicant.requestedAmount,
  통화단위: applicant.currency,
  비고: applicant.note
}));

// 일괄 저장 (단일 API)
const newIds = await sheets.createApplicationsBatch(applicationDataList);
```

**수정 파일 및 위치:**

| 파일 | 라인 | 변경 내용 |
|------|------|----------|
| `src/processors/process-pair-sheets.js` | 626-688 | 신청현황 생성 루프 → 배치 |
| `src/processors/process-pair-sheets.js` | 570-615 | 운용사 생성 루프 → 배치 |
| `src/processors/process-pair-sheets.js` | 731-738 | 약어 업데이트 루프 → 배치 |

**예상 효과:**

| 작업 | 현재 API 호출 | 개선 후 | 감소율 |
|------|-------------|---------|--------|
| 신청현황 생성 (170건) | 340회 | 2회 | **170배** |
| 운용사 생성 (50건) | 100회 | 2회 | **50배** |
| 약어 업데이트 (10건) | 20회 | 1회 | **20배** |

---

### 2.2 파일-출자사업 연결 추가

**문제:** `updateProjectFileId()` 함수가 구현되어 있으나 호출하지 않음

**현재 코드:**
```javascript
// process-pair-sheets.js:520-533
const appFileHistory = await sheets.getOrCreateFileHistory(...);
const selFileHistory = await sheets.getOrCreateFileHistory(...);
// ← updateProjectFileId() 호출 없음!
```

**개선 코드:**
```javascript
// [4] 파일DB 생성
const appFileHistory = await sheets.getOrCreateFileHistory(...);
const selFileHistory = await sheets.getOrCreateFileHistory(...);

// [4-1] 출자사업-파일 연결 (추가)
await sheets.updateProjectFileId(project.id, '접수현황', appFileHistory.id);
await sheets.updateProjectFileId(project.id, '선정결과', selFileHistory.id);
```

**수정 파일 및 위치:**

| 파일 | 라인 | 변경 내용 |
|------|------|----------|
| `src/processors/process-pair-sheets.js` | 533 이후 | 2줄 추가 |

**예상 효과:**
- `/verify` 명령 정상 동작
- 출자사업 시트의 지원파일ID, 결과파일ID 자동 입력
- 파일-출자사업 추적 가능

---

### 2.3 정규화 함수 통합

**문제:** 4곳에서 다른 정규화 로직 사용 → 매칭 오류

**현재 상태:**
```javascript
// 위치 1: operator-matcher.js:133 (괄호 제거)
.replace(/[()（）\[\]【】]/g, '')

// 위치 2: process-pair-sheets.js:329 (괄호 → 공백)
.replace(/[,.\-()]/g, ' ')

// 위치 3: review-workflow.js:478 (괄호 → 공백)
.replace(/[,.\-()]/g, ' ')

// 위치 4: utils/verify-operator-matching.js:51
```

**개선 방안 - 신규 모듈 생성:**

```javascript
// src/utils/normalize.js (신규)

/**
 * 운용사명 정규화 (전체 시스템에서 통일)
 * @param {string} name - 원본 운용사명
 * @returns {string} - 정규화된 이름
 */
export function normalizeName(name) {
  if (!name) return '';

  return name
    .toLowerCase()
    .replace(/[()（）\[\]【】]/g, '')  // 괄호 제거
    .replace(/[,.\\-_&]/g, ' ')        // 특수문자 → 공백
    .replace(/\\s+/g, ' ')             // 연속 공백 제거
    .trim();
}

/**
 * 영문 접미사 제거 (비교 시에만 사용)
 * @param {string} name - 정규화된 이름
 * @returns {string} - 접미사 제거된 이름
 */
export function removeEnglishSuffix(name) {
  const suffixes = /\\b(llc|inc|ltd|pte|limited|management|company|co|corp|corporation)\\b/gi;
  return name.replace(suffixes, '').trim().replace(/\\s+/g, ' ');
}

/**
 * 투자사 접미사 제거 (유사도 비교용)
 * @param {string} name - 정규화된 이름
 * @returns {string} - 접미사 제거된 이름
 */
export function removeInvestmentSuffix(name) {
  const suffixes = /(인베스트먼트|벤처스|파트너스|캐피탈|자산운용|투자|에셋)$/;
  return name.replace(suffixes, '').trim();
}
```

**기존 파일 수정:**

```javascript
// operator-matcher.js
import { normalizeName, removeEnglishSuffix } from '../utils/normalize.js';
// 기존 normalizeName 함수 삭제

// process-pair-sheets.js
import { normalizeName, removeEnglishSuffix } from '../utils/normalize.js';
// 기존 normalizeName 함수 삭제

// review-workflow.js
import { normalizeName } from '../utils/normalize.js';
// 기존 normalizeName 함수 삭제
```

**수정 파일 및 위치:**

| 파일 | 변경 내용 |
|------|----------|
| `src/utils/normalize.js` | 신규 생성 |
| `src/matchers/operator-matcher.js` | import 추가, 기존 함수 삭제 |
| `src/processors/process-pair-sheets.js` | import 추가, 기존 함수 삭제 |
| `src/workflows/review-workflow.js` | import 추가, 기존 함수 삭제 |

---

### 2.4 중복 데이터 읽기 제거 (1회 읽기 후 캐싱)

**문제:** 같은 시트를 여러 번 읽어 불필요한 API 호출 발생

**현재 중복 읽기 패턴:**

| 시트 | 읽기 횟수 | 호출 위치 |
|------|----------|----------|
| 운용사 | 2-3회 | `reviewNewOperators()`, `loadAliasMap()`, `findOperatorByName()` |
| 신청현황 | 2-4회 | `getExistingApplications()`, `updateProjectStatus()`, `findRow()` |

**상세 분석:**

```javascript
// 현재 코드 - 운용사 시트 중복 읽기
// [5.5] 유사도 검토 (385번 줄)
const existingOperators = await sheets.getAllOperators();  // 읽기 1

// [2] 약어 맵 로드 (508번 줄) - 내부에서 또 읽음
aliasCache = await sheets.loadAliasMap();  // 읽기 2 (getAllRows('운용사') 호출)

// [6] 개별 운용사 검색 - 매번 전체 테이블 조회
await sheets.findOperatorByName(name);  // 읽기 3, 4, 5... (루프 시)
```

```javascript
// 현재 코드 - 신청현황 시트 중복 읽기
// [5] 기존 신청현황 조회 (537번 줄)
existingApplications = await sheets.getExistingApplications(project.id);  // 읽기 1

// [10] 현황 업데이트 (779번 줄) - 내부에서 또 읽음
await sheets.updateProjectStatus(project.id);  // 읽기 2 (getAllRows('신청현황') 호출)
```

**개선 방안 - 초기 1회 로드 후 메모리 캐싱:**

```javascript
// process-pair-sheets.js 개선

async function processPair(appFileNum, selFileNum) {
  // === 초기 데이터 로드 (1회씩만) ===

  // 운용사 전체 로드 → Map으로 캐싱
  const allOperators = await sheets.getAllOperators();  // 단 1회!
  const operatorMap = new Map();
  const operatorByNameMap = new Map();
  const aliasToOperatorMap = new Map();

  for (const op of allOperators) {
    operatorMap.set(op['ID'], op);
    operatorByNameMap.set(op['운용사명'], op);

    // 약어 매핑도 동시에 구성
    if (op['약어']) {
      for (const alias of op['약어'].split(',').map(a => a.trim())) {
        aliasToOperatorMap.set(alias, op);
      }
    }
  }

  // 신청현황 전체 로드 → Map으로 캐싱
  const allApplications = await sheets.getAllRows('신청현황');  // 단 1회!
  const applicationsByProject = new Map();

  for (const app of allApplications) {
    const projectId = app['출자사업ID'];
    if (!applicationsByProject.has(projectId)) {
      applicationsByProject.set(projectId, []);
    }
    applicationsByProject.get(projectId).push(app);
  }

  // === 이후 모든 조회는 메모리에서 ===

  // 운용사 검색 (API 호출 없음)
  function findOperatorByName(name) {
    return operatorByNameMap.get(name) || null;
  }

  // 약어로 검색 (API 호출 없음)
  function findOperatorByAlias(alias) {
    return aliasToOperatorMap.get(alias) || null;
  }

  // 기존 신청현황 조회 (API 호출 없음)
  function getExistingApplications(projectId) {
    return applicationsByProject.get(projectId) || [];
  }

  // === 나머지 처리 로직 ===
  // ... (캐시된 데이터 사용)
}
```

**googleSheets.js 캐싱 레이어 추가:**

```javascript
// src/core/googleSheets.js 개선

class GoogleSheetsClient {
  constructor() {
    this._cache = new Map();  // 시트별 캐시
    this._cacheTimestamp = new Map();  // 캐시 시간
    this._cacheTTL = 5 * 60 * 1000;  // 5분 TTL
  }

  /**
   * 캐시된 getAllRows - 같은 세션 내 중복 호출 방지
   */
  async getAllRowsCached(sheetName) {
    const now = Date.now();
    const cached = this._cache.get(sheetName);
    const timestamp = this._cacheTimestamp.get(sheetName);

    // 캐시 유효 시 반환
    if (cached && timestamp && (now - timestamp) < this._cacheTTL) {
      return cached;
    }

    // 캐시 없거나 만료 시 조회
    const rows = await this.getAllRows(sheetName);
    this._cache.set(sheetName, rows);
    this._cacheTimestamp.set(sheetName, now);

    return rows;
  }

  /**
   * 캐시 무효화 (쓰기 작업 후)
   */
  invalidateCache(sheetName) {
    this._cache.delete(sheetName);
    this._cacheTimestamp.delete(sheetName);
  }

  /**
   * 전체 캐시 클리어
   */
  clearCache() {
    this._cache.clear();
    this._cacheTimestamp.clear();
  }
}
```

**수정 파일 및 위치:**

| 파일 | 변경 내용 |
|------|----------|
| `src/processors/process-pair-sheets.js` | 초기 로드 후 메모리 Map 사용 |
| `src/core/googleSheets.js` | 캐싱 레이어 추가 (`getAllRowsCached`, `invalidateCache`) |

**예상 효과:**

| 시트 | 현재 읽기 | 개선 후 | 감소율 |
|------|----------|---------|--------|
| 운용사 | 2-3회 | 1회 | **66-75%** |
| 신청현황 | 2-4회 | 1회 | **50-75%** |
| 출자사업 | 2회 | 1회 | **50%** |
| **총 API 읽기** | ~10-15회 | ~3-5회 | **60-70%** |

**주의사항:**
- 쓰기 작업 후 해당 시트 캐시 무효화 필수
- `appendRows()`, `setValues()` 후 `invalidateCache()` 호출

---

## 3. Phase 2: 구조 개선 (High)

### 3.1 검토 후 저장 구조 (트랜잭션 패턴)

**문제:** 검토 전에 DB 변경 → 취소 시 고아 데이터

**현재 흐름:**
```
[3] 출자사업 생성 ← DB 변경
[4] 파일DB 생성 ← DB 변경
[5.5] 운용사 생성 ← DB 변경
[6] 검토 화면 (사용자 입력 대기)
[사용자 거절] → 이미 생성된 데이터가 고아로 남음
```

**개선 흐름:**
```
[1-5] 모든 데이터 파싱 및 검증 (메모리에서만)
      ├─ 출자사업 정보 준비 (projectData)
      ├─ 파일DB 정보 준비 (fileData)
      ├─ 운용사 정보 준비 (pendingOperators)
      └─ 신청현황 정보 준비 (pendingApplications)
[6] 검토 화면 (사용자 입력 대기)
[사용자 승인 후에만]
[7] DB 저장 (일괄)
      ├─ sheets.getOrCreateProject()
      ├─ sheets.getOrCreateFileHistory()
      ├─ sheets.createOperatorsBatch()
      └─ sheets.createApplicationsBatch()
```

**구현 방안:**

```javascript
// process-pair-sheets.js 구조 변경

async function processPair(appFileNum, selFileNum) {
  // === Phase A: 데이터 수집 (메모리만) ===

  // [1-2] PDF 로드 및 파싱
  const { applicants, selected } = await parseFiles(appFileNum, selFileNum);

  // [3-4] 출자사업/파일 정보 준비 (저장 X)
  const projectData = prepareProjectData(projectName);
  const fileData = prepareFileData(appFileNum, selFileNum);

  // [5] 기존 데이터 로드 (읽기만)
  const existingOperators = await sheets.getAllOperators();
  const operatorMap = new Map(existingOperators.map(op => [op['운용사명'], op]));

  // [5.5] 유사도 검토 - 신규 운용사 수집 (저장 X)
  const { pendingOperators, operatorMappings } = await reviewNewOperators(
    applicants,
    operatorMap
  );

  // [6] 검토 화면
  const reviewData = {
    applicants,
    selected,
    pendingOperators,
    projectData,
    stats
  };

  const approved = await review.start(reviewData);

  if (!approved) {
    console.log('\n처리가 취소되었습니다.');
    process.exit(0);  // 아무것도 저장되지 않음
  }

  // === Phase B: 승인 후 일괄 저장 ===

  // [7] 출자사업 생성
  const project = await sheets.getOrCreateProject(projectData.name, projectData.meta);

  // [8] 파일DB 생성 및 연결
  const appFile = await sheets.getOrCreateFileHistory(fileData.app);
  const selFile = await sheets.getOrCreateFileHistory(fileData.sel);
  await sheets.updateProjectFileId(project.id, '접수현황', appFile.id);
  await sheets.updateProjectFileId(project.id, '선정결과', selFile.id);

  // [9] 운용사 일괄 생성
  const newOperatorIds = await sheets.createOperatorsBatch(pendingOperators);

  // [10] 신청현황 일괄 생성
  const applicationData = prepareApplicationData(applicants, operatorMappings, newOperatorIds);
  await sheets.createApplicationsBatch(applicationData);

  // [11] 약어 일괄 업데이트
  await sheets.updateOperatorAliasesBatch(newAliases);

  // [12] 파일 상태 업데이트
  await sheets.syncFileStatusWithApplications(appFile.id);
  await sheets.syncFileStatusWithApplications(selFile.id);
}
```

**핵심 변경점:**
1. `getOrCreateOperator()` → 메모리에서 매핑 준비 후 `createOperatorsBatch()`
2. 검토 거절 시 DB에 아무 변경 없음
3. 승인 후 모든 저장이 한 번에 실행

---

### 3.2 탈락 상태 업데이트 로직

**문제:** 분리 처리 시 "접수" 상태가 "탈락"으로 변경되지 않음

**시나리오:**
1. 접수현황만 먼저 처리 → 모든 신청현황 "접수" 상태
2. 나중에 선정결과 처리 → 선정된 운용사만 "선정"으로 변경
3. 선정되지 않은 운용사는 여전히 "접수" (탈락이어야 함)

**개선 방안:**

```javascript
// process-pair-sheets.js - 선정결과 단독 처리 시 추가

async function updateRejectedStatus(projectId, selectedOperatorIds) {
  // 해당 출자사업의 모든 신청현황 조회
  const allApplications = await sheets.getAllApplicationsByProject(projectId);

  // 선정된 운용사 ID Set
  const selectedSet = new Set(selectedOperatorIds);

  // "접수" 상태이고 선정 명단에 없으면 → "탈락"
  const updateTargets = allApplications.filter(app =>
    app['상태'] === '접수' && !selectedSet.has(app['운용사ID'])
  );

  if (updateTargets.length > 0) {
    console.log(`\n탈락 처리: ${updateTargets.length}건`);

    // 배치 업데이트
    await sheets.updateApplicationStatusBatch(
      updateTargets.map(app => ({ id: app['ID'], status: '탈락' }))
    );
  }
}

// 선정결과 처리 완료 후 호출
await updateRejectedStatus(project.id, processedSelectedIds);
```

**신규 메서드 필요:**

```javascript
// googleSheets.js에 추가

/**
 * 신청현황 상태 일괄 업데이트
 */
async updateApplicationStatusBatch(updates) {
  // updates: [{ id: 'AP0001', status: '탈락' }, ...]
  const rows = await this.getAllRows('신청현황');

  for (const { id, status } of updates) {
    const row = rows.find(r => r['ID'] === id);
    if (row) {
      await this.setValues(`신청현황!I${row._rowIndex}`, [[status]]);
    }
  }
}
```

---

### 3.3 에러 복구 로직 (체크포인트)

**문제:** 부분 실패 시 복구 불가능, 재실행 시 중복 생성

**개선 방안 - 체크포인트 시스템:**

```javascript
// src/utils/checkpoint.js (신규)

import fs from 'fs';
import path from 'path';

const CHECKPOINT_DIR = './checkpoints';

export class CheckpointManager {
  constructor(sessionId) {
    this.sessionId = sessionId;
    this.filePath = path.join(CHECKPOINT_DIR, `${sessionId}.json`);
    this.state = {
      stage: 'init',
      completedOperators: [],
      completedApplications: [],
      timestamp: null
    };
  }

  /**
   * 체크포인트 저장
   */
  async save(stage, data = {}) {
    this.state = {
      ...this.state,
      ...data,
      stage,
      timestamp: new Date().toISOString()
    };

    if (!fs.existsSync(CHECKPOINT_DIR)) {
      fs.mkdirSync(CHECKPOINT_DIR, { recursive: true });
    }

    fs.writeFileSync(this.filePath, JSON.stringify(this.state, null, 2));
    console.log(`[Checkpoint] ${stage} 저장됨`);
  }

  /**
   * 체크포인트 로드
   */
  load() {
    if (fs.existsSync(this.filePath)) {
      this.state = JSON.parse(fs.readFileSync(this.filePath, 'utf8'));
      console.log(`[Checkpoint] ${this.state.stage}에서 재개`);
      return this.state;
    }
    return null;
  }

  /**
   * 체크포인트 삭제 (완료 시)
   */
  clear() {
    if (fs.existsSync(this.filePath)) {
      fs.unlinkSync(this.filePath);
      console.log('[Checkpoint] 삭제됨');
    }
  }
}

/**
 * API 재시도 래퍼
 */
export async function withRetry(fn, options = {}) {
  const { maxRetries = 3, retryDelay = 60000 } = options;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      if (error.code === 429 || error.message.includes('Quota')) {
        console.log(`[Retry] API 할당량 초과, ${retryDelay/1000}초 대기 후 재시도 (${attempt}/${maxRetries})`);
        await sleep(retryDelay);
      } else {
        throw error;
      }
    }
  }

  throw new Error('최대 재시도 횟수 초과');
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}
```

**process-pair-sheets.js 적용:**

```javascript
import { CheckpointManager, withRetry } from '../utils/checkpoint.js';

async function processPair(appFileNum, selFileNum) {
  const sessionId = `${appFileNum}-${selFileNum}-${Date.now()}`;
  const checkpoint = new CheckpointManager(sessionId);

  // 기존 체크포인트 확인
  const savedState = checkpoint.load();
  if (savedState) {
    console.log(`이전 작업 재개: ${savedState.stage}`);
    // 완료된 항목 스킵 로직
  }

  try {
    // [7] 운용사 생성
    await checkpoint.save('operators-start');
    const newOperatorIds = await withRetry(() =>
      sheets.createOperatorsBatch(pendingOperators)
    );
    await checkpoint.save('operators-done', { completedOperators: Object.keys(newOperatorIds) });

    // [8] 신청현황 생성
    await checkpoint.save('applications-start');
    await withRetry(() =>
      sheets.createApplicationsBatch(applicationData)
    );
    await checkpoint.save('applications-done');

    // 완료 후 체크포인트 삭제
    checkpoint.clear();

  } catch (error) {
    console.error('오류 발생:', error.message);
    console.log(`체크포인트 저장됨: ${checkpoint.filePath}`);
    console.log('재실행하면 마지막 체크포인트에서 재개됩니다.');
    process.exit(1);
  }
}
```

---

## 4. Phase 3: 품질 개선 (Medium)

### 4.1 PDF 이중 파싱 재활성화

**문제:** Claude AI만 사용, pdfplumber 비교/병합 미사용

**개선 방안:**

```javascript
// process-pair-sheets.js

import { parseWithPdfplumber } from './pdf-parser-bridge.js';
import { compareResults, mergeResults } from './pdf-compare.js';

async function parseApplicationPdf(pdfText, pdfFile) {
  // 방법 1: Claude AI
  const aiResult = await parseWithClaude(pdfText, pdfFile);

  // 방법 2: pdfplumber
  const plumberResult = await parseWithPdfplumber(pdfFile.path);

  // 비교 및 병합
  const comparison = compareResults(aiResult, plumberResult);

  if (comparison.hasConflicts) {
    console.log('\n[PDF 파싱 결과 비교]');
    console.log(`일치: ${comparison.matched.length}건`);
    console.log(`AI만 발견: ${comparison.aiOnly.length}건`);
    console.log(`pdfplumber만 발견: ${comparison.plumberOnly.length}건`);
    console.log(`충돌: ${comparison.conflicts.length}건`);

    // 충돌 시 사용자 확인
    const confirmed = await confirmConflicts(comparison.conflicts);
    if (!confirmed) {
      throw new Error('PDF 파싱 충돌 해결 필요');
    }
  }

  // 병합 결과 반환 (Claude 우선)
  return mergeResults(aiResult, plumberResult, comparison);
}
```

---

### 4.2 전역 변수 제거

**문제:** 8개의 전역 변수로 상태 관리 → 테스트/재사용 불가

**현재:**
```javascript
let sheets = null;
let aliasCache = null;
let stats = null;
let createdAppIds = null;
let newAliases = null;
let existingApplications = null;
let project = null;
let fileDBIds = null;
```

**개선 방안 - Context 객체:**

```javascript
class ProcessingContext {
  constructor(sheetsClient) {
    this.sheets = sheetsClient;
    this.aliasCache = new Map();
    this.stats = {
      total: 0,
      created: 0,
      skipped: 0,
      errors: 0
    };
    this.createdAppIds = [];
    this.newAliases = [];
    this.existingApplications = new Map();
    this.project = null;
    this.fileDBIds = { app: null, sel: null };
  }

  reset() {
    this.stats = { total: 0, created: 0, skipped: 0, errors: 0 };
    this.createdAppIds = [];
    this.newAliases = [];
  }
}

// 사용
async function processPair(appFileNum, selFileNum) {
  const ctx = new ProcessingContext(new GoogleSheetsClient());

  // 모든 함수에 ctx 전달
  await parseFiles(ctx, appFileNum, selFileNum);
  await reviewOperators(ctx);
  await saveData(ctx);
}
```

---

### 4.3 하드코딩 제거

**문제:**
```javascript
// 소관이 하드코딩됨
소관: isDomestic ? '중기부' : 'KVIC(해외VC)'

// 공고유형이 항상 '정시'
공고유형: '정시'

// 연도가 항상 현재 연도
연도: new Date().getFullYear().toString()
```

**개선 방안:**

```javascript
// PDF 파일명에서 메타데이터 추출
function extractProjectMeta(filename, pdfContent) {
  const meta = {
    소관: null,
    공고유형: null,
    연도: null,
    차수: null
  };

  // 파일명 패턴: 중기부_2024년_1차_정시_접수현황.pdf
  const filenameMatch = filename.match(
    /^(중기부|문체부|과기부|해양부|KVIC|모태펀드)_(\d{4})년_(\d+)차_(정시|수시)/
  );

  if (filenameMatch) {
    meta.소관 = filenameMatch[1];
    meta.연도 = filenameMatch[2];
    meta.차수 = filenameMatch[3] + '차';
    meta.공고유형 = filenameMatch[4];
  }

  // PDF 내용에서 추가 확인
  if (pdfContent.includes('수시')) meta.공고유형 = '수시';
  if (pdfContent.includes('해외')) meta.소관 = 'KVIC(해외VC)';

  return meta;
}
```

---

## 5. 구현 상세

### 5.1 수정 파일 목록

| 파일 | Phase | 수정 유형 | 주요 변경 |
|------|-------|----------|----------|
| `src/utils/normalize.js` | 1 | 신규 | 정규화 함수 통합 |
| `src/utils/checkpoint.js` | 2 | 신규 | 체크포인트/재시도 |
| `src/processors/process-pair-sheets.js` | 1,2,3 | 대규모 수정 | 배치, 트랜잭션, 연결, 캐싱 |
| `src/matchers/operator-matcher.js` | 1 | import 변경 | 정규화 함수 교체 |
| `src/workflows/review-workflow.js` | 1 | import 변경 | 정규화 함수 교체 |
| `src/core/googleSheets.js` | 1,2 | 메서드 추가 | 캐싱 레이어, 배치 업데이트 |

### 5.2 의존성 변경

```
기존:
process-pair-sheets.js
├── googleSheets.js
├── review-workflow.js
└── operator-matcher.js (각각 자체 normalizeName)

개선 후:
process-pair-sheets.js
├── googleSheets.js
├── review-workflow.js
├── operator-matcher.js
├── utils/normalize.js (공유)
└── utils/checkpoint.js (신규)
```

---

## 6. 테스트 및 검증

### 6.1 Phase 1 검증

**배치 메서드 적용:**
```bash
# API 호출 로깅 활성화
DEBUG=api node src/processors/process-pair-sheets.js 81 1

# 예상 결과: API 호출 ~10회 (기존 ~540회)
```

**파일-출자사업 연결:**
```bash
# 처리 후 확인
node -e "
const sheets = new (require('./src/core/googleSheets.js').default)();
sheets.init().then(async () => {
  const project = await sheets.findRow('출자사업', 'ID', 'PJ0001');
  console.log('지원파일ID:', project['지원파일ID']);
  console.log('결과파일ID:', project['결과파일ID']);
});
"
```

**정규화 일관성:**
```bash
# 테스트 케이스
node -e "
const { normalizeName } = require('./src/utils/normalize.js');
const tests = [
  'ABC (Korea) Inc.',
  '한국투자파트너스(주)',
  'KB인베스트먼트'
];
tests.forEach(t => console.log(t, '->', normalizeName(t)));
"
```

**중복 읽기 제거:**
```bash
# API 호출 로깅으로 시트별 읽기 횟수 확인
DEBUG=sheets node src/processors/process-pair-sheets.js 81 1

# 예상 결과:
# [sheets] getAllRows('운용사') - 1회만 호출
# [sheets] getAllRows('신청현황') - 1회만 호출
# [sheets] getAllRows('출자사업') - 1회만 호출
```

### 6.2 Phase 2 검증

**트랜잭션 구조:**
1. PDF 처리 시작
2. 검토 화면에서 'n' 입력 (거절)
3. Google Sheets에서 신규 운용사/신청현황 없음 확인

**탈락 업데이트:**
1. 접수현황 파일만 처리 → 모든 상태 "접수"
2. 선정결과 파일 처리
3. 선정 명단에 없는 운용사의 상태가 "탈락"으로 변경 확인

**에러 복구:**
1. 처리 중 Ctrl+C로 중단
2. `checkpoints/` 폴더에 체크포인트 파일 생성 확인
3. 재실행 시 이전 체크포인트에서 재개 확인

### 6.3 통합 테스트

```bash
# 전체 워크플로우 테스트
npm run test:integration

# 또는 수동 테스트
node src/processors/process-pair-sheets.js 119 44
node src/verify-project.js PJ0065
```

---

## 7. 롤백 계획

### 7.1 Phase 1 롤백

**배치 메서드:**
- 롤백 방법: 개별 루프 코드 주석 해제
- 위험도: 낮음 (기능 동일, 성능만 저하)

**파일 연결:**
- 롤백 방법: `updateProjectFileId()` 호출 2줄 제거
- 위험도: 낮음 (기존과 동일하게 동작)

**정규화 함수:**
- 롤백 방법: 각 파일에 원래 함수 복원, import 제거
- 위험도: 중간 (정규화 불일치 재발)

### 7.2 Phase 2 롤백

**트랜잭션 구조:**
- 롤백 방법: 기존 순서로 복원 (저장 → 검토)
- 위험도: 중간 (고아 데이터 재발)
- 주의: 커밋 히스토리에서 이전 버전 참조

**에러 복구:**
- 롤백 방법: checkpoint.js import 제거, 관련 코드 삭제
- 위험도: 낮음 (기존과 동일)

### 7.3 백업

```bash
# 개선 전 백업
git tag pre-optimization-$(date +%Y%m%d)
git push origin --tags
```

---

## 부록: 관련 문서

- [260114-비효율검토요약보고서.md](260114-비효율검토요약보고서.md) - 분석 보고서
- [260114-구현흐름.md](260114-구현흐름.md) - 현재 구현 흐름 문서
- [CLAUDE.md](../CLAUDE.md) - 프로젝트 가이드
